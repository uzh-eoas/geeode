{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"\ud83c\udf0d\ud83d\udd70\ufe0fGEEODE\ud83d\udcc8\ud83d\udcc9 A Google Earth Engine Implementation of Optimization by Differential Evolution"},{"location":"#summary","title":"Summary","text":"<p>Do you commonly use time series data in Google Earth Engine (Henceforth: GEE) and are you interested in modelling these time series using mathematical functions of arbitrary forms (e.g., linear, exponential, logarithmic, etc.)? If so, consider GEEODE as an option for your task.</p> <p>With <code>geeode</code> you can optimize any arbitrary close-formed alegbraic model on a time series image collection using a process called differential evolution. Various options exist to fine-tune the analysis, and accompanying statistics measuring the degree of optimization (i.e., \"convergence\" to a final model) can also be produced.</p> <p>For full references and additional information, see the paper.</p> <p>For questions please contact Devin Routh and/or Claudia R\u00f6\u00f6sli with the University of Z\u00fcrich Earth Observation Application and Services group.</p>"},{"location":"#getting-started-installation","title":"Getting Started / Installation","text":"<p>The analytical functionality offered by <code>geeode</code> is available both via the Google Earth Engine Javascript Code Editor as well as by using the GEE Python Module.</p> <p>To begin immediately, follow the quickstart.</p>"},{"location":"#javascript","title":"Javascript","text":"<p>You can access the analytical functions of <code>geeode</code> simply by importing the native GEE module, like so:</p> <pre><code>// Import geeode\nvar de_optim = require('users/uzheoas/geeode:geeode.js');\n</code></pre> <p>Note: the Javascript implementation of <code>geeode</code> only includes the analytical functions and none of the helper functions (e.g., <code>pause_and_wait</code>).</p>"},{"location":"#python","title":"Python","text":"<p>The Python implementation of <code>geeode</code> offers both the analytical functionality as well as the workflow functions.</p> <p>To use <code>geeode</code> from Python, install it from source via:</p> <pre><code>git clone https://github.com/uzh-eoas/geeode.git\ncd geeode\npip install -e .\n</code></pre>"},{"location":"api/","title":"Function Reference","text":""},{"location":"api/#geeode.geeode.de_optim","title":"<code>de_optim(pop_size=int, iNum=int, funToOpt=str, inputVars=list[str], inputBounds=list[list[float]], timeSeries=ee.ImageCollection, bandName=str, optParams={})</code>","text":"<p>Perform differential\u2011evolution optimization on an Earth Engine time\u2011series.</p> <p>Parameters:</p> Name Type Description Default <code>pop_size</code> <code>int</code> <p>the number of population members when generating a new population</p> <code>int</code> <code>iNum</code> <code>int</code> <p>the number of iterations</p> <code>int</code> <code>funToOpt</code> <code>str</code> <p>the function you want to optimize in the form of a GEE expression; the function must include the time band as well as all variables you'll be optimizing; band names must be formatted using the prescribed GEE format <code>b('...')</code> </p> <code>str</code> <code>inputVars</code> <code>list[str]</code> <p>a list of the names of the variables you will optimize</p> <code>list[str]</code> <code>inputBounds</code> <code>list[list[float]]</code> <p>a list of lists; each sublist describes the numeric bounds (inclusive) that will be used for each variable; the order must match the <code>inputVars</code> list</p> <code>list[list[float]]</code> <code>timeSeries</code> <code>ImageCollection</code> <p>the image collection time series being modelled; each image must have the raw data being modelled as a band name (identified below) as well as a time band and a properly formatted <code>system:footprint</code></p> <code>ImageCollection</code> <code>bandName</code> <code>str</code> <p>the band name of the raw data being modelled; each image in the time series must contain this band</p> <code>str</code> <code>optParams</code> <code>dict</code> <p>optional dictionary of additional parameters; see \"Other Parameters\" below</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>timeBand</code> <code>String, default 'time'</code> <p>name of the time band:</p> <code>mutationStrategy</code> <code>String, default rand</code> <p>mutation strategy; possible values are <code>rand</code> and <code>best</code></p> <code>M</code> <code>Float, default 0.5</code> <p>mutation factor \\(M in (0,2]\\) within the function \\(v_x + M * (v_y \u2013 v_z)\\) where \\(v_x\\),\\(v_y\\), and \\(v_z\\) are population members</p> <code>cr</code> <code>Float, default 0.7</code> <p>crossover factor for the binomial selection process \\(cr in (0,1)\\)</p> <code>computeScree</code> <code>Boolean, default False</code> <p><code>True</code> if you want to return a scree image, else <code>False</code></p> <code>initialPopSeed</code> <code>Integer, default 1</code> <p>the seed used to generate the initial population</p> <code>parallelScale</code> <code>Integer, default 1</code> <p>the <code>parallelScale</code> value used to input into relevant EE functions; \\(in {1 ... 16}\\)</p> <code>daisyChain</code> <code>Boolean, default False</code> <p><code>True</code> if you want to return the final iteration population image (i.e., an array-image), else <code>False</code></p> <code>startingPopulationImage</code> <code>ee.Image, default null</code> <p>the <code>ee.Image</code> object to input as a starting population image; must have a Integer value property <code>seedNum</code> and must be an array-image formatted according to the variables being optimized</p> <code>existingScreeImage</code> <code>ee.Image, default null</code> <p>the <code>ee.Image</code> image to input as a starting scree image; should be an object computed from <code>computeScree</code></p> <code>verbosePrinting</code> <code>Boolean, default False</code> <p>if <code>True</code>, print info upong running</p> <p>Returns:</p> Type Description <code>Image</code> <p>a coefficients image, scree\u2011plot image, or population image depending on the options selected (e.g., <code>computeScree</code> or <code>daisyChain</code>)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if required inputs are missing or malformed (e.g., mismatched variable lists, missing bounds, or invalid mutation strategy)</p> Notes <ul> <li>The function performs extensive type\u2011checking and default\u2011value handling before running the core DE algorithm.</li> <li>It supports optional \u201cdaisy\u2011chain\u201d processing and can generate a scree plot of RMSE values across iterations.</li> </ul> <p>Examples:</p> <pre><code>result = de_optim(\n    pop_size=10,\n    iNum=25,\n    funToOpt=\"b('time') * b('a') + b('b')\",\n    inputVars=[\"a\", \"b\"],\n    inputBounds=[[0, 1], [0, 10]],\n    timeSeries=time_series,\n    bandName=\"NDVI\",\n)\n</code></pre> Source code in <code>src/geeode/geeode.py</code> <pre><code>def de_optim(pop_size = int,\n             iNum = int ,\n             funToOpt = str,\n             inputVars = list[str],\n             inputBounds = list[list[float]],\n             timeSeries = ee.ImageCollection,\n             bandName = str,\n             optParams = {}):\n\n    \"\"\"\n    Perform differential\u2011evolution optimization on an Earth Engine time\u2011series.\n\n    Args:\n        pop_size (int): the number of population members when generating a new population\n        iNum (int): the number of iterations\n        funToOpt (str): the function you want to optimize in the form of a GEE expression; the function must include the time band as well as all variables you'll be optimizing; band names must be formatted using the prescribed GEE format `b('...')` \n        inputVars (list[str]): a list of the names of the variables you will optimize\n        inputBounds (list[list[float]]): a list of lists; each sublist describes the numeric bounds (inclusive) that will be used for each variable; the order must match the `inputVars` list\n        timeSeries (ee.ImageCollection): the image collection time series being modelled; each image must have the raw data being modelled as a band name (identified below) as well as a time band and a properly formatted `system:footprint`\n        bandName (str): the band name of the raw data being modelled; each image in the time series must contain this band\n        optParams (dict, optional): optional dictionary of additional parameters; see \"Other Parameters\" below\n\n    Other Parameters:\n        timeBand (String, default 'time'): name of the time band:\n        mutationStrategy (String, default rand): mutation strategy; possible values are `rand` and `best`\n        M (Float, default 0.5): mutation factor $M in (0,2]$ within the function $v_x + M * (v_y \u2013 v_z)$ where $v_x$,$v_y$, and $v_z$ are population members\n        cr (Float, default 0.7): crossover factor for the binomial selection process $cr in (0,1)$\n        computeScree (Boolean, default False): `True` if you want to return a scree image, else `False`\n        initialPopSeed (Integer, default 1): the seed used to generate the initial population\n        parallelScale (Integer, default 1): the `parallelScale` value used to input into relevant EE functions; $in {1 ... 16}$\n        daisyChain (Boolean, default False): `True` if you want to return the final iteration population image (i.e., an array-image), else `False`\n        startingPopulationImage (ee.Image, default null): the `ee.Image` object to input as a starting population image; must have a Integer value property `seedNum` and must be an array-image formatted according to the variables being optimized\n        existingScreeImage (ee.Image, default null): the `ee.Image` image to input as a starting scree image; should be an object computed from `computeScree`\n        verbosePrinting (Boolean, default False): if `True`, print info upong running\n\n\n    Returns:\n        (ee.Image): a coefficients image, scree\u2011plot image, or population image depending on the options selected (e.g., ``computeScree`` or ``daisyChain``)\n\n    Raises:\n        ValueError: if required inputs are missing or malformed (e.g., mismatched variable lists, missing bounds, or invalid mutation strategy)\n\n    Notes:\n        * The function performs extensive type\u2011checking and default\u2011value handling before running the core DE algorithm.\n        * It supports optional \u201cdaisy\u2011chain\u201d processing and can generate a scree plot of RMSE values across iterations.\n\n    Examples:\n        ```python\n        result = de_optim(\n            pop_size=10,\n            iNum=25,\n            funToOpt=\"b('time') * b('a') + b('b')\",\n            inputVars=[\"a\", \"b\"],\n            inputBounds=[[0, 1], [0, 10]],\n            timeSeries=time_series,\n            bandName=\"NDVI\",\n        )\n        ```\n\n    \"\"\"\n\n    # !! Before anything else, perform default value setting and type checking\n    # !! to assist users with inputting the proper values\n\n    try:\n        timeBand = optParams['timeBand']\n    except KeyError:\n        optParams['timeBand'] = 'time'\n        timeBand = optParams['timeBand']\n\n    try:\n        mutationStrategy = optParams['mutationStrategy']\n    except KeyError:\n        optParams['mutationStrategy'] = 'rand'\n        mutationStrategy = optParams['mutationStrategy']\n\n    try:\n        M = optParams['M']\n    except KeyError:\n        optParams['M'] = 0.5\n        M = optParams['M']\n\n    try:\n        cr = optParams['cr']\n    except KeyError:\n        optParams['cr'] = 0.5\n        cr = optParams['cr']\n\n    try:\n        computeScree = optParams['computeScree']\n    except KeyError:\n        optParams['computeScree'] = False\n        computeScree = optParams['computeScree']\n\n    try:\n        initialPopSeed = optParams['initialPopSeed']\n    except KeyError:\n        optParams['initialPopSeed'] = 1\n        initialPopSeed = optParams['initialPopSeed']\n\n    try:\n        parallelScale = optParams['parallelScale']\n    except KeyError:\n        optParams['parallelScale'] = 1\n        parallelScale = optParams['parallelScale']\n\n    try:\n        daisyChain = optParams['daisyChain']\n    except KeyError:\n        optParams['daisyChain'] = False\n        daisyChain = optParams['daisyChain']\n\n    try:\n        startingPopulationImage = optParams['startingPopulationImage']\n    except KeyError:\n        optParams['startingPopulationImage'] = None\n        startingPopulationImage = optParams['startingPopulationImage']\n\n    try:\n        existingScreeImage = optParams['existingScreeImage']\n    except KeyError:\n        optParams['existingScreeImage'] = None\n        existingScreeImage = optParams['existingScreeImage']\n\n    try:\n        verbosePrinting = optParams['verbosePrinting']\n    except KeyError:\n        optParams['verbosePrinting'] = False\n        verbosePrinting = optParams['verbosePrinting']\n\n    # Check that the function is formatted correctly\n    propBandRegEx = \"b\\\\('[a-zA-Z]+'\\\\)\";\n    varPreRegEx = \"b\\\\('\";\n    varSuffRegEx = \"'\\\\)\";\n    matches = re.findall(propBandRegEx,funToOpt)\n\n    if len(matches) == 0:\n        raise ValueError(\"Your function must include all of the bands you would like to analyze in the appropriate format (including your specified time band); i.e., b('bandname').\")\n\n    allVarsList = inputVars + [timeBand];\n    matches = re.findall(propBandRegEx,funToOpt)\n    if len(matches) == 0:\n        raise ValueError(\"Your function must include all of the bands you would like to analyze in the appropriate format (including your specified time band); i.e., b('bandname').\")\n    matches = [re.sub(varPreRegEx, '', s) for s in matches]\n    matches = [re.sub(varSuffRegEx, '', s) for s in matches]\n    if set(allVarsList) != set(matches):\n        raise ValueError(\"Make sure your inputted variable list and the variables in your inputted function match!\")\n\n    # Check that input bounds are given for every variable\n    if len(inputVars) != len(inputBounds):\n      raise ValueError(\"You must supply a numeric bounds for each of the input variables. Ensure your order is correct!\");\n\n    # Compute / retrieve an area of interest if producing a population image for daisy chaining\n    if daisyChain == True:\n      aOI = ee.Geometry(ee.Image(timeSeries.first()).get('system:footprint'));\n      if aOI.getInfo() == None:\n        raise ValueError(\"Your time series lacks a proper 'system:footprint'. Set one for each image in the collection then retry the function!\");\n\n    # !! Begin the algorithm once inputs are checked\n\n    # Format the variable dictionary with relevant information after sorting the zipped inputs\n    sortedVarsBoundsDict = dict(sorted(dict(zip(inputVars,inputBounds)).items()))\n    varsList = list(sortedVarsBoundsDict.keys())\n    boundsList = list(sortedVarsBoundsDict.values())\n    varsDict = ee.Dictionary.fromLists(varsList,boundsList);\n\n    # Create an initial population array image of candidate solutions;\n    # Initialize an array image with the appropriate population number\n    # wherein every population member vector is the appropriate size\n    numOfVarsToOpt = ee.Dictionary(varsDict).size();\n    boundsDictKeys = ee.List(varsList);\n    boundsArray = ee.Dictionary(varsDict).toArray(varsList);\n    def forBoundsRangesArray(k,v):\n        return ee.Number(ee.List(v).get(1)).subtract(ee.Number(ee.List(v).get(0)));\n    boundsRangesArray = varsDict.map(forBoundsRangesArray).toArray(varsList).repeat(1,pop_size).transpose(1,0);\n    def forBoundsMinsArray(k,v):\n        return ee.Number(ee.List(v).get(0));\n    boundsMinsArray = varsDict.map(forBoundsMinsArray).toArray(varsList).repeat(1,pop_size).transpose(1,0);\n    arrayImageToMultiply = ee.Image(boundsRangesArray).toArray();\n    arrayImageToAdd = ee.Image(boundsMinsArray).toArray();\n    numElements = (boundsArray.reduce('count',[0]).reduce('sum',[1])\n        .project([0]).get([0]));\n    reshapeImage = ee.Image([pop_size,numOfVarsToOpt]).toArray();\n    initialPopImage = (ee.ImageCollection(ee.List.sequence(1,ee.Number(pop_size).multiply(boundsDictKeys.size()))\n            .map(lambda n: ee.Image.random(ee.Number(n).add(ee.Number(initialPopSeed).multiply(1e4)))))\n        .toArrayPerBand()\n        .arrayReshape(reshapeImage,2)\n        .multiply(arrayImageToMultiply).add(arrayImageToAdd));\n\n    # ~~~~~~~~~~~~~~~~\n    # Iterate through the algorithm the instructed number of times\n    # ~~~~~~~~~~~~~~~~\n\n    # Make an iteration number collection that can be mapped as an \n    # image/feature collection; first, acquire the starting seed number\n    if (startingPopulationImage == None):\n        startingSeedNumber = 0;\n    else:\n        startingSeedNumber = int(ee.Number(ee.Image(startingPopulationImage).get('seed_num')).getInfo());\n    def makeIterArray(n):\n        return list(range(1+startingSeedNumber,n+1+startingSeedNumber))\n    iterJSArray = ee.List(makeIterArray(iNum));\n    iterColl = ee.ImageCollection(iterJSArray.map(lambda n: ee.Image.constant(n).set('seed_num',ee.Number(n))));\n\n    # Take count of how many scree bands there are (if the image is provided)\n    if existingScreeImage == None:\n        numExtantScreeBandsPlus1 = 1;\n    else:\n        numExtantScreeBandsPlus1 = ee.Number(ee.Image(existingScreeImage).bandNames().length()).add(1);\n\n    # Make a population number collection that can be mapped as an \n    # image/feature collection\n    def makeArray(n):\n        return list(range(0,n))\n    popsizeJSArray = ee.List(makeArray(pop_size));\n    popsizeColl = ee.ImageCollection(popsizeJSArray.map(lambda n: ee.Image.constant(n).set('iter_num',ee.Number(n))))\n\n    # Make RMSE required functions\n    # First, make a string for computing RMSE via the .expression() function;\n    # this string will be used in multiple functions computing RMSE\n    beforeString = ee.String(\"(b('\");\n    afterString = ee.String(\"') - b('modeled')) ** 2\");\n    desiredString = beforeString.cat(bandName).cat(afterString);\n\n    # Make a function that computes the summed/total RMSE for a collection\n    def computeRMSEForColl(collToUse,imageToAssess):\n        # Map a function across the inputted collection to make a modeled layer,\n        # then sum the residuals and compute RMSE\n        def makeSquaredResiduals(i):\n            bandsAdded = i.addBands(imageToAssess);\n            modeledValue = bandsAdded.addBands(bandsAdded.expression(funToOpt).rename('modeled'));\n            return modeledValue.addBands(modeledValue.expression(desiredString).rename('squaredResiduals'));\n        modeledValue = collToUse.map(makeSquaredResiduals);\n        meanRMSE = ee.Image(modeledValue.select('squaredResiduals').reduce('mean',parallelScale)).rename('mean');\n        finalRMSE = meanRMSE.sqrt().rename('RMSE');\n        return finalRMSE;\n\n    # Add RMSE to each set of potential coefficients using the time series\n    def addRMSE(collWithCoeffs,timeSeries):\n        # Map a function across the inputted collection to make a modeled layer,\n        # then sum the residuals and compute RMSE\n        def makeRMSEImages(i):\n            def makeSquaredResiduals(tsi):\n                tsWithBands = tsi.addBands(i);\n                tsWithPredictions = tsWithBands.addBands(tsWithBands.expression(funToOpt).rename('modeled'));\n                tsWithSquaredResids = i.addBands(tsWithPredictions.expression(desiredString).rename('squaredResiduals'));\n                return tsWithSquaredResids;\n            tsWithRMSE = timeSeries.map(makeSquaredResiduals)\n            meanRMSE = ee.Image(tsWithRMSE.select('squaredResiduals').reduce('mean',parallelScale)).rename('mean');\n            finalRMSE = meanRMSE.sqrt().rename('RMSE');\n            inverseRMSE = ee.Image.constant(1).divide(finalRMSE).rename('inverseRMSE');\n            return i.addBands(finalRMSE).addBands(inverseRMSE);\n        rmseImages = collWithCoeffs.map(makeRMSEImages);\n        return rmseImages;\n\n    # Make a function that accepts an initial population image as its main\n    # argument maps through the iteration collection and choose candidate\n    # vectors randomly, then compare them with the trial vector and choose\n    # the best candiate via a crossover function;\n    # !! Adjust this last whenever augmenting the available strategies in the\n    # !! mutatePopulation() function below.\n    strategyList = [\"rand\", \"best\"];\n\n    try:\n        strategyList.index(mutationStrategy)\n    except ValueError:\n        print('Invalid mutation strategy chosen. Choose one of:');\n        print(strategyList);\n        raise ValueError('Input one of the suggested strategies (as a string object).') ;\n\n    def mutatePopulation(iPI,seedFactor,screeBandNum):\n        def mutateCollection(i):\n            # Acquire the iteration number\n            iterNum = ee.Number(ee.Image(i).get('iter_num'));\n            iterNumPlus1 = iterNum.add(1);\n\n            # Use the number to remove the nth vector in the array\n            firstSlice = ee.Image(iPI).arraySlice(0,0,iterNum,1);\n            secondSlice = ee.Image(iPI).arraySlice(0,iterNumPlus1,pop_size,1);\n            arrayImageMinusN = firstSlice.arrayCat(secondSlice,0);\n\n            # Also, save the nth vector from the array\n            mutationNVector = ee.Image(iPI).arraySlice(0,iterNum,iterNumPlus1);\n\n            # Shuffle the array and slice off the top 3 members\n            reshapeKeysImage = ee.Image([pop_size - 1,1]).toArray();\n            arrayKeys = (ee.ImageCollection(ee.List(makeArray(pop_size - 1)).map(lambda s:\n                ee.Image.random(ee.Number(s).add(seedFactor).add(iterNum.multiply(1e3)))\n                ))\n            .toArrayPerBand().arrayReshape(reshapeKeysImage,2));\n            shuffled = arrayImageMinusN.arraySort(arrayKeys);\n            sliced = shuffled.arraySlice(0,0,3);\n\n            # Mutation operation to make a mutated vector\n\n            # Mutation: rand\n            array0 = sliced.arraySlice(0,0,1);\n            array1 = sliced.arraySlice(0,1,2);\n            array2 = sliced.arraySlice(0,2,3);\n            fArray = ee.Image(M).toArray().arrayRepeat(1,numOfVarsToOpt);\n            mutationOpt1 = fArray.multiply(array1.subtract(array2));\n            mutatedVector_DE_Rand_1 = array0.add(mutationOpt1);\n\n            # Mutation: best\n            # Add RMSE to each set of potential coefficients using the global time series variable\n            # Make a function to add RMSE to each set of potential coefficients using the time series\n            def addRMSEToImage(i):\n                def tsiFunction(tsi):\n                    tsWithBands = tsi.addBands(i);\n                    tsWithPredictions = tsWithBands.addBands(tsWithBands.expression(funToOpt).rename('modeled'));\n                    tsWithSquaredResids = i.addBands(tsWithPredictions.expression(desiredString).rename('RMSE'));\n                    return tsWithSquaredResids;\n                tsWithSquaredResids = timeSeries.map(tsiFunction)\n                meanRMSE = ee.Image(tsWithSquaredResids.select('RMSE').reduce('mean', 2)).rename('mean');\n                finalRMSE = meanRMSE.sqrt().rename('RMSE');\n                inverseRMSE = ee.Image.constant(1).divide(finalRMSE).rename('inverseRMSE');\n                return i.addBands(finalRMSE).addBands(inverseRMSE);\n\n            def iPIToRMSEHelper(i):\n                # Acquire the iteration number\n                iterNum = ee.Number(ee.Image(i).get('iter_num'));\n                iterNumPlus1 = iterNum.add(1);\n                # Save the nth array\n                mutationNVector = ee.Image(iPI).arraySlice(0, iterNum, iterNumPlus1);\n                # Flatten to an image\n                imageToReturn = mutationNVector.arrayProject([1]).arrayFlatten([inputVars]);\n                return imageToReturn;\n\n            iPIWithRMSE = popsizeColl.map(iPIToRMSEHelper).map(addRMSEToImage)\n            arrayToSortForBest = iPIWithRMSE.select(varsList).toArray();\n            keysForArraySortForBest = iPIWithRMSE.select('RMSE').toArray();\n            sortedArrayForBest = arrayToSortForBest.arraySort(keysForArraySortForBest);\n            bestVector = sortedArrayForBest.arraySlice(0, 0, 1);\n            mutatedVector_DE_Best_1 = bestVector.add(mutationOpt1);\n\n            # Return the desired mutated vector\n            availableStrategies = ee.List(strategyList);\n            mutationStrategyInput = ee.String(mutationStrategy);\n            chosenStrategyValue = ee.Algorithms.If(mutationStrategyInput.equals(\"rand\"), mutatedVector_DE_Rand_1,\n                ee.Algorithms.If(mutationStrategyInput.equals(\"best\"), mutatedVector_DE_Best_1, \"NA\"));\n            mutatedVector = chosenStrategyValue;\n\n            # Convert to a multiband image for bounds clipping\n            mutatedVectorMultiband = ee.Image(mutatedVector).arrayProject([1]).arrayFlatten([varsList]);\n            def minBoundsToMultibandfunction(k,v):\n                return ee.Number(ee.List(v).get(0));\n            minBoundsMultiband = varsDict.map(minBoundsToMultibandfunction).toImage().select(varsList);\n            def maxBoundsToMultibandfunction(k,v):\n                return ee.Number(ee.List(v).get(1));\n            maxBoundsMultiband = varsDict.map(maxBoundsToMultibandfunction).toImage().select(varsList);\n            clippedMutatedVectorMultiband = (mutatedVectorMultiband\n                                             .where(mutatedVectorMultiband.lt(minBoundsMultiband),minBoundsMultiband)\n                                             .where(mutatedVectorMultiband.gt(maxBoundsMultiband),maxBoundsMultiband));\n\n            # Create an image of crossover random values for the crossover binomial trials\n            def makeCrossOver(c):\n                return (ee.Image.random(ee.Number(c).add(seedFactor).add(iterNum.multiply(1e3))));\n            crossOverRandomValue = (ee.ImageCollection(ee.List(makeArray(len(varsList)))\n                                                                  .map(makeCrossOver))\n                                    .toArrayPerBand().arrayFlatten([varsList]));\n\n            crResult = []\n            for v in varsList:\n                crResult.append(cr)\n            crImage = ee.Image(crResult).rename(varsList)\n\n            # Create a trial vector multiband image\n            targetVectorMultiband = mutationNVector.arrayProject([1]).arrayFlatten([varsList]);\n\n            # Apply the crossover function\n            trialVectorMultiband = targetVectorMultiband.where(crossOverRandomValue.lt(crImage),clippedMutatedVectorMultiband);\n\n            # Apply the objective function to the target and trial images\n            targetObjApplied = computeRMSEForColl(timeSeries,targetVectorMultiband);\n            trialObjApplied = computeRMSEForColl(timeSeries,trialVectorMultiband);\n            finalVectorToStore = targetVectorMultiband.where(trialObjApplied.lt(targetObjApplied),trialVectorMultiband);\n\n            return finalVectorToStore;\n\n        mutationColl = popsizeColl.map(mutateCollection)\n        mutationArray = mutationColl.toBands().toArray().arrayReshape(ee.Image([pop_size,numOfVarsToOpt]).toArray(),2);\n\n        # Convert the array to a collection for RMSE calculation\n        def convertToArrayForScreeRMSE(i):\n            # Acquire the iteration number\n            iterNum = ee.Number(ee.Image(i).get('iter_num'));\n            iterNumPlus1 = iterNum.add(1);\n            # Save the nth array\n            mutationNVector = ee.Image(mutationArray).arraySlice(0,iterNum,iterNumPlus1);\n            # Flatten to an image\n            imageToReturn = mutationNVector.arrayProject([1]).arrayFlatten([varsList]);\n            return imageToReturn;\n        icForRMSECalc = popsizeColl.map(convertToArrayForScreeRMSE)\n        finalCollForScreeCacl = addRMSE(icForRMSECalc,timeSeries);\n\n        # Calculate the best/lowest RMSE\n        finalRMSEImage = ee.Image(finalCollForScreeCacl.select('RMSE').reduce('min',parallelScale));\n        screeBandsToAdd = (ee.Image(ee.Image(iPI).get('scree')).addBands(finalRMSEImage.rename(ee.String('RMSE_').cat(ee.Number.parse(screeBandNum).add(numExtantScreeBandsPlus1).format('%03d')))));\n\n        return mutationArray.set('scree',ee.Image(screeBandsToAdd)).set('seed_num',ee.Number(seedFactor).divide(1e12));\n\n    # According to the two image arguments, accept pre-defined population and scree images\n    if (startingPopulationImage == None) and (existingScreeImage == None):\n        screeImageForIterate = ee.Image();\n        startingImageForIterate = initialPopImage.set('seed_num', 0).set('scree',screeImageForIterate);\n    elif (startingPopulationImage == None) and (existingScreeImage != None):\n        screeImageForIterate = ee.Image(existingScreeImage);\n        startingImageForIterate = initialPopImage.set('seed_num', 0).set('scree', screeImageForIterate);\n    elif (startingPopulationImage != None) and (existingScreeImage == None):\n        screeImageForIterate = ee.Image();\n        startingImageForIterate = ee.Image(startingPopulationImage).set('scree', screeImageForIterate);\n    else:\n        screeImageForIterate = ee.Image(existingScreeImage);\n        startingImageForIterate = ee.Image(startingPopulationImage).set('scree', screeImageForIterate);\n\n    # Iterate the function the specified number of times\n    def collectionIterate(current,result):\n        return mutatePopulation(result,ee.Number(current.get('seed_num')).multiply(1e12),ee.Number(current.get('system:index')));\n    populationOutput = iterColl.iterate(collectionIterate,startingImageForIterate);\n    screeImage = ee.Image(ee.Image(populationOutput).get('scree'));\n\n    def flattenImageColl(i):\n        # Acquire the iteration number\n        iterNum = ee.Number(ee.Image(i).get('iter_num'));\n        iterNumPlus1 = iterNum.add(1);\n        # Save the nth array\n        mutationNVector = ee.Image(populationOutput).arraySlice(0,iterNum,iterNumPlus1);\n        # Flatten to an image\n        imageToReturn = mutationNVector.arrayProject([1]).arrayFlatten([varsList]);\n        return imageToReturn;\n    flattenedIC = popsizeColl.map(flattenImageColl);\n\n    finalColl = addRMSE(flattenedIC,timeSeries);\n\n    # Use quality mosaic to determine the best chromosome\n    mosaicedImage = finalColl.qualityMosaic('inverseRMSE');\n\n    # Return the parameters or the scree plot depending on what is requested\n    if (daisyChain == False):\n        if verbosePrinting == True:\n            print(\"DE Optim is returning a:\")\n        if (computeScree == True):\n            if verbosePrinting == True:\n                print(\"Scree Image\");\n                print(\"\");\n            bN = screeImage.bandNames().getInfo()\n            rString = re.compile(\"REMOVE_[0-9]+\")\n            removeList = list(filter(rString.match, bN))\n            return screeImage.select(screeImage.bandNames().removeAll(removeList).removeAll(['REMOVE']));\n        else:\n            if verbosePrinting == True:\n                print(\"Coefficients Image\");\n                print(\"\");\n            return mosaicedImage.select(mosaicedImage.bandNames().remove('inverseRMSE'));\n    else:\n        if verbosePrinting == True:\n            print(\"DE Optim is returning a:\")\n        if (computeScree == False):\n            if verbosePrinting == True:\n                print(\"Population Image\");\n                print(\"\");\n            return ee.Image(populationOutput);\n        else:\n            if verbosePrinting == True:\n                print(\"Scree Image\");\n                print(\"\");\n            bN = screeImage.bandNames().getInfo()\n            rString = re.compile(\"REMOVE_[0-9]+\")\n            removeList = list(filter(rString.match, bN))\n            return screeImage.select(screeImage.bandNames().removeAll(removeList));\n</code></pre>"},{"location":"api/#geeode.geeode.sub_sample","title":"<code>sub_sample(iC=ee.ImageCollection, nKeep=int, sType=str, bandName=str, optParams={})</code>","text":"<p>Subsamples an image collection by temporal density.</p> <p>Parameters:</p> Name Type Description Default <code>iC</code> <code>ImageCollection</code> <p>the GEE image collection to subsample</p> <code>ImageCollection</code> <code>nKeep</code> <code>int</code> <p>the number of observations to keep at every pixel (maximum)</p> <code>int</code> <code>sType</code> <code>str</code> <p>the subsampling type you'd like to perform; one of 'bulk', 'splitshuffle', leapfrog'</p> <code>str</code> <code>bandName</code> <code>str</code> <p>the name of the band (in the image collection) containing your value of interest</p> <code>str</code> <p>Other Parameters:</p> Name Type Description <code>nStD</code> <code>float, default 0.5</code> <p>the number of standard deviations to use a kernel width when calculating temporal density</p> <code>timeBandName</code> <code>str, default 'time'</code> <p>the name of time band in each image</p> <code>sN</code> <code>int, default 4</code> <p>the number of splits if using the 'splitshuffle' mtehod</p> <code>seedNum</code> <code>int, default 1</code> <p>the random seed use for shuffling</p> <code>verbosePrinting</code> <code>Boolean, default False</code> <p>if <code>True</code>, print info upon running</p> <p>Returns:</p> Type Description <code>Image</code> <p>an image comprised of <code>nKeep</code> paired bands; each pair of bands includes the time value and the original observed band values at that time</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if required inputs are missing or malformed (e.g., <code>nStD</code> must be positive)</p> Notes <ul> <li>Time data from the individual images in the input collection will be lost after using this function.</li> </ul> <p>Examples:</p> <pre><code>sampled_collection = sub_sample(\n    iC=your_image_collection,\n    nKeep=30,\n    sType='leapfrog',\n    bandName='NDVI\n)\n</code></pre> Source code in <code>src/geeode/geeode.py</code> <pre><code>def sub_sample(iC = ee.ImageCollection,\n               nKeep = int,\n               sType = str,\n               bandName = str,\n               optParams = {}):\n    \"\"\"\n    Subsamples an image collection by temporal density.\n\n    Args:\n        iC (ee.ImageCollection): the GEE image collection to subsample\n        nKeep (int): the number of observations to keep at every pixel (maximum)\n        sType (str): the subsampling type you'd like to perform; one of 'bulk', 'splitshuffle', leapfrog'\n        bandName (str): the name of the band (in the image collection) containing your value of interest\n\n    Other Parameters:  \n        nStD (float, default 0.5): the number of standard deviations to use a kernel width when calculating temporal density\n        timeBandName (str, default 'time'): the name of time band in each image\n        sN (int, default 4): the number of splits if using the 'splitshuffle' mtehod\n        seedNum (int, default 1): the random seed use for shuffling\n        verbosePrinting (Boolean, default False): if `True`, print info upon running\n\n    Returns:\n        (ee.Image): an image comprised of `nKeep` paired bands; each pair of bands includes the time value and the original observed band values at that time\n\n    Raises:\n        ValueError: if required inputs are missing or malformed (e.g., `nStD` must be positive)\n\n    Notes:\n        * Time data from the individual images in the input collection will be lost after using this function.\n\n    Examples:\n        ```python\n        sampled_collection = sub_sample(\n            iC=your_image_collection,\n            nKeep=30,\n            sType='leapfrog',\n            bandName='NDVI\n        )\n        ```\n\n    \"\"\"\n\n    # Set optional values to defaults if they are not explicitly defined\n    try:\n        nStD = optParams['nStD']\n    except KeyError:\n        optParams['nStD'] = 0.5\n        nStD = optParams['nStD']\n\n    if nStD &lt;= 0:\n        raise ValueError('nStD must be greater than 0!')\n\n    try:\n        timeBandName = optParams['timeBandName']\n    except KeyError:\n        optParams['timeBandName'] = 'time'\n        timeBandName = optParams['timeBandName']\n\n    try:\n        sN = optParams['sN']\n    except KeyError:\n        optParams['sN'] = 4\n        sN = optParams['sN']\n\n    if sN &lt;= 0:\n        raise ValueError('sN must be greater than 0!')\n\n    try:\n        seedNum = optParams['seedNum']\n    except KeyError:\n        optParams['seedNum'] = 1\n        seedNum = optParams['seedNum']\n\n    try:\n        verbosePrinting = optParams['verbosePrinting']\n    except KeyError:\n        optParams['verbosePrinting'] = False\n        verbosePrinting = optParams['verbosePrinting']\n\n    # Calculate the desired time standard deviation value\n    i_c_time_std_dev_nstd = iC.select(timeBandName).reduce(ee.Reducer.stdDev()).multiply(nStD)\n\n    # Add \u00b1 min/max times (based on nStD) for temporal filtering\n    def map_i(i):\n        return i.addBands(i.select(timeBandName).add(i_c_time_std_dev_nstd).rename('max_time')) \\\n                 .addBands(i.select(timeBandName).subtract(i_c_time_std_dev_nstd).rename('minTime'))\n\n    i_c_with_min_max = iC.map(map_i)\n\n    # Filter based on \u00b1min/max\n    def min_max_filter(o):\n        def min_max_inner(i):\n            test_band = i.select(timeBandName).gt(o.select('minTime')) \\\n                        .And(i.select(timeBandName).lt(o.select('max_time'))) \\\n                        .rename('density').updateMask(i.select(bandName).mask())\n            value_to_sum = i.addBands(test_band)\n            return value_to_sum\n\n        density_band = i_c_with_min_max.map(min_max_inner).select('density').sum()\n        return o.addBands(density_band.updateMask(o.select(bandName).mask())) \\\n                 .addBands(ee.Image.random(seedNum).add(1).rename('random').updateMask(o.select(bandName).mask())) \\\n                 .addBands(density_band.multiply(ee.Image.random(seedNum).add(1)).rename('weight').updateMask(o.select(bandName).mask()))\n\n    density_coll = i_c_with_min_max.map(min_max_filter)\n\n    keys_shuffle = density_coll.select('weight').toArray()\n\n    # Shuffle the time series values according to temporal density weight\n    original_ts = density_coll.select(bandName, timeBandName).toArray()\n    density_coll_shuffled = original_ts.arraySort(keys_shuffle)\n\n    # Format array images that will serve as array masks, allowing for subsampled values to \n    # be returned or for their complement to be returned (i.e., the masked out values)\n    ts_length = density_coll_shuffled.arrayLength(0)\n    n_to_remove_diff = ee.Image(ts_length).subtract(nKeep)\n    n_to_remove = n_to_remove_diff.where(n_to_remove_diff.lte(ee.Image.constant(0)), 0)\n    on_off_array = ee.Image([1, 0]).toArray()\n    off_off_array = ee.Image([0, 0]).toArray()\n    on_off_repeated = on_off_array.arrayRepeat(0, n_to_remove)\n    on_off_repeated_sliced = on_off_repeated.arraySlice(0, 0, ts_length)\n    on_off_repeated_sliced_length = on_off_repeated_sliced.arrayLength(0)\n    on_off_repeated_keep_sliced_keep_sum = on_off_repeated_sliced.arrayReduce('sum', [0])\n    additional_number_to_remove = on_off_repeated_keep_sliced_keep_sum.multiply(ee.Image([0])) \\\n        .where(on_off_repeated_keep_sliced_keep_sum.arrayFlatten(\n            [['n']]\n        ).subtract(ee.Image(nKeep)).gt(0),\n            on_off_repeated_keep_sliced_keep_sum.subtract(nKeep))\n    on_off_repeated_length = on_off_repeated.arrayLength(0)\n    off_off_repeated = off_off_array.arrayRepeat(0, additional_number_to_remove.arrayFlatten(\n        [['n']]\n    ))\n    off_off_repeated_length = off_off_repeated.arrayLength(0)\n\n    # Format arrays that will be used if the default leap-frog sampling \"laps\" the\n    # total number of samples (i.e., the sampling removes more than half of the original time series)\n    aggro_slice_length = on_off_repeated_sliced_length.subtract(off_off_repeated_length)\n    on_off_repeated_sliced_with_aggro_sampling = on_off_repeated_sliced.arraySlice(0, 0, aggro_slice_length)\n    aggro_mask_array = on_off_repeated_sliced_with_aggro_sampling.arrayCat(off_off_repeated, 0)\n    keep_vector = ee.Image([1]).arrayRepeat(0, ts_length.subtract(on_off_repeated_length))\n    normal_mask_array = keep_vector.arrayCat(on_off_repeated, 0)\n\n    # Finalize the mask to use for the time series\n    mask_test = on_off_repeated_length.gt(ts_length)\n    mask_array = normal_mask_array.where(mask_test, aggro_mask_array)\n\n    # Format the band names for the flattened image\n    def format_number(n):\n        return ee.String('b').cat(ee.Number(n).format('%02d'))\n\n    n_l = ee.List.sequence(1, nKeep).map(format_number)\n\n    # Bulk sampling\n    bulk_sampling_sliced = density_coll_shuffled.arraySlice(0, 0, nKeep)\n    bulk_sampling_time_keys = bulk_sampling_sliced.arraySlice(1, -1)\n    bulk_sampled_array_image = bulk_sampling_sliced.arraySort(bulk_sampling_time_keys)\n    sub_sampled_image_bulk = bulk_sampled_array_image.arrayPad([nKeep, 2]).arrayFlatten([n_l, [bandName, timeBandName]], '_').selfMask()\n\n    # Split shuffle sampling\n    # Use the sN (number of splits) input to split the array pseudo randomly\n    # (i.e., weighted by temporal density) and subsample them\n    def make_constant_image(i):\n        return ee.Image.constant(i).set('n', i)\n\n    n_coll = ee.ImageCollection(ee.List.sequence(0, (sN - 1)).map(make_constant_image))\n\n    def array_slice_collection(i):\n        return ee.Image(density_coll_shuffled).arraySlice(axis = 0, start = ee.Image(i).int(), step = sN)\n\n    split_shuffled_arrays = n_coll.map(array_slice_collection).toArrayPerBand()\n    density_coll_sliced_split_shuffled = split_shuffled_arrays.arraySlice(axis = 0, end = ee.Image.constant(nKeep))\n    keys_time_split_shuffled = density_coll_sliced_split_shuffled.arraySlice(1, -1)\n    density_coll_sorted_split_shuffled = density_coll_sliced_split_shuffled.arraySort(keys_time_split_shuffled)\n    density_coll_padded_split_shuffled = density_coll_sorted_split_shuffled.arrayPad([nKeep, 2])\n    sub_sampled_image_split_shuffled = density_coll_padded_split_shuffled.arrayFlatten([n_l, [bandName, timeBandName]], '_').selfMask()\n\n    # Apply the array-mask to confirm the subsampling (leapfrog)\n    density_coll_masked_lf = density_coll_shuffled.arrayMask(mask_array.arrayRepeat(1, ee.Image(1)))\n    time_sorting_keys_lf = density_coll_masked_lf.arraySlice(axis = 1, start = ee.Image.constant(-1))\n    density_coll_masked_sorted_lf = density_coll_masked_lf.arraySort(time_sorting_keys_lf)\n\n    # Mask the flattened array-image with itself to remove 0 values\n    sub_sampled_image_lf = density_coll_masked_sorted_lf.arrayPad([nKeep, 2]).arrayFlatten([n_l, [bandName, timeBandName]], '_').selfMask()\n\n    # Return the image collection of interest\n    if sType == 'bulk':\n        if verbosePrinting == True:\n            print('Bulk Sampling')\n        image_to_return = sub_sampled_image_bulk\n    elif sType == 'splitshuffle':\n        if verbosePrinting == True:\n            print('Split Shuffle Sampling')\n        image_to_return = sub_sampled_image_split_shuffled\n    elif sType == 'leapfrog':\n        if verbosePrinting == True:\n            print('Leapfrog Sampling')\n        image_to_return = sub_sampled_image_lf\n    else:\n        raise ValueError(\"Input one of: 'bulk', 'splitshuffle', or 'leapfrog'.\")\n        image_to_return = None\n\n    return image_to_return\n</code></pre>"},{"location":"api/#geeode.geeode.ts_image_to_coll","title":"<code>ts_image_to_coll(ts_image=ee.Image, band_name=str, ts_length=int)</code>","text":"<p>A function used to take an outputted image from the <code>sub_sample</code> function and transforms it back into an image collection wherein every image has a 'time' band and a band the contains the original sampled observation at that time.</p> <p>Images in the collection have no time data at the asset/image level; time data now exists as a band value. The first image in the collection has the earliest observation for each pixel (subsampled from the original stack of values at each pixel), the second image has the second earliest, and so on in temporal order.</p> <p>Parameters:</p> Name Type Description Default <code>ts_image</code> <code>Image</code> <p>the image outputted from the <code>sub_sample</code> function</p> <code>Image</code> <code>band_name</code> <code>str</code> <p>the original band name of the values being sampled</p> <code>str</code> <code>ts_length</code> <code>int</code> <p>the number of samples maintained from the original time series per pixel</p> <code>int</code> <p>Returns: (ee.ImageCollection): returns an image collection with the time and original observations as bands in each image</p> <p>Examples:</p> <pre><code>sampled_collection = sub_sample(\n    i_c=your_image_collection,\n    n_keep=n_observations_to_keep,\n    s_type='leapfrog',\n    band_name='NDVI'\n)\nts_image_to_coll(sampled_collection,'NDVI',n_observations_to_keep)\n</code></pre> Source code in <code>src/geeode/geeode.py</code> <pre><code>def ts_image_to_coll(ts_image = ee.Image,\n                     band_name = str,\n                     ts_length = int,):\n    \"\"\"\n\n    A function used to take an outputted image from the `sub_sample` function\n    and transforms it back into an image collection wherein every image has a 'time'\n    band and a band the contains the original sampled observation at that time.\n\n    Images in the collection have no time data at the asset/image level; time data\n    now exists as a band value. The first image in the collection has the earliest\n    observation for each pixel (subsampled from the original stack of values at each\n    pixel), the second image has the second earliest, and so on in temporal order.\n\n    Args:\n     ts_image (ee.Image): the image outputted from the `sub_sample` function\n     band_name (str): the original band name of the values being sampled\n     ts_length (int): the number of samples maintained from the original time series per pixel\n\n    Returns:\n    (ee.ImageCollection): returns an image collection with the time and original observations as bands in each image\n\n    Examples:\n        ```python\n        sampled_collection = sub_sample(\n            i_c=your_image_collection,\n            n_keep=n_observations_to_keep,\n            s_type='leapfrog',\n            band_name='NDVI'\n        )\n        ts_image_to_coll(sampled_collection,'NDVI',n_observations_to_keep)\n        ```\n    \"\"\"\n    # Make a function to create a client-side list of numbers\n    def make_iter_array(start, end):\n        return list(range(start, end + 1))\n\n    # Make a function to pad the number with leading zeros\n    def zero_pad(num, places):\n        return str(num).zfill(places)\n\n    # Make a function that cracks open the image bands and returns them in a form that the ee.ImageCollection.fromImages() function can handle\n    def unzip_bands(i):\n        padded_num = zero_pad(i + 1, 2)\n        main_band = f\"b{padded_num}_{band_name}\"\n        time_band = f\"b{padded_num}_time\"\n\n        image_to_add = ee.Image(ts_image).select([main_band, time_band], [{band_name}, 'time'])\n        return image_to_add\n\n    # Create the list of indices\n    i_l = make_iter_array(0, ts_length - 1)\n\n    # Create the ImageCollection\n    ts_coll = ee.ImageCollection.fromImages([unzip_bands(i) for i in i_l])\n    return ts_coll\n</code></pre>"},{"location":"api/#geeode.geeode.apply_model","title":"<code>apply_model(time_series=ee.ImageCollection, de_optim_output=ee.Image, fun_to_opt=str)</code>","text":"<p>Apply a model expression to each image in a collection.</p> <p>Parameters:</p> Name Type Description Default <code>time_series</code> <code>ImageCollection</code> <p>The input time series ImageCollection on which to apply the model</p> <code>ImageCollection</code> <code>de_optim_output</code> <code>Image</code> <p>The coefficient image returned by <code>de_optim</code></p> <code>Image</code> <code>fun_to_opt</code> <code>str</code> <p>A string expression to evaluate; e.g., \"b('time') * b('a') + b('b')\"</p> <code>str</code> <p>Returns:</p> Type Description <code>ImageCollection</code> <p>The collection with a new band named 'predicted'</p> Source code in <code>src/geeode/geeode.py</code> <pre><code>def apply_model(time_series = ee.ImageCollection,\n                de_optim_output = ee.Image,\n                fun_to_opt = str):\n    \"\"\"\n    Apply a model expression to each image in a collection.\n\n    Args:\n        time_series (ee.ImageCollection): The input time series ImageCollection on which to apply the model\n        de_optim_output (ee.Image): The coefficient image returned by `de_optim`\n        fun_to_opt (str): A string expression to evaluate; e.g., \"b('time') * b('a') + b('b')\"\n\n    Returns:\n        (ee.ImageCollection): The collection with a new band named 'predicted'\n    \"\"\"\n\n    def apply_expression(image):\n        # Add the de_optim_output bands, evaluate the expression, and rename the result.\n        predicted = image.addBands(de_optim_output) \\\n                       .expression(fun_to_opt) \\\n                       .rename('predicted')\n        # Preserve original bands.\n        return image.addBands(predicted)\n\n    coll_with_predictions = time_series.map(apply_expression)\n    return coll_with_predictions\n</code></pre>"},{"location":"api/#geeode.geeode.pause_and_wait","title":"<code>pause_and_wait(unique_id=str, wait_time=60, try_again=False, max_time=None)</code>","text":"<p>A helper function used to take a \"pause\" in a workflow to \"wait\" for tasks to finish.</p> <p>Every time the function runs, it checks for tasks in the queue that contain 'unique' as a substring in their description and are queued either as RUNNING or READY. The function then lists the number of tasks (1 or more) that match the criteria, prints how many there are alongside the time, then waits the specified number of checks before following the same protocol once again.</p> <p>Parameters:</p> Name Type Description Default <code>unique_id</code> <code>str</code> <p>will be used to find tasks in your queue that are RUNNING or READY</p> <code>str</code> <code>wait_time</code> <code>int</code> <p>the number of seconds to wait before rechecking for tasks</p> <code>60</code> <code>try_again</code> <code>bool</code> <p>if True and there are errors, continue trying to check for tasks</p> <code>False</code> <code>max_time</code> <code>int</code> <p>tasks</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required inputs are malformed (e.g., <code>wait_time</code> must be positive).</p> Notes <ul> <li>To interrupt the waiting, simply use a keyboard escape method.</li> <li>Use the <code>try_again</code> and <code>max_time</code> arguments deliberately.<ul> <li><code>try_again</code> can cause the code to continue indefinitely</li> <li><code>max_time</code> can/will CANCEL tasks in the queue</li> </ul> </li> </ul> <p>Examples:</p> <pre><code>pauseAndWait('task_unique_string')\n</code></pre> Source code in <code>src/geeode/geeode.py</code> <pre><code>def pause_and_wait(unique_id = str,\n                   wait_time = 60,\n                   try_again = False,\n                   max_time = None):\n    \"\"\"\n    A helper function used to take a \"pause\" in a workflow to \"wait\" for tasks to finish.\n\n    Every time the function runs, it checks for tasks in the queue that contain 'unique'\n    as a substring in their description and are queued either as RUNNING or READY. The\n    function then lists the number of tasks (1 or more) that match the criteria, prints\n    how many there are alongside the time, then waits the specified number of checks\n    before following the same protocol once again.\n\n    Args:\n        unique_id (str): will be used to find tasks in your queue that are RUNNING or READY\n        wait_time (int): the number of seconds to wait before rechecking for tasks\n        try_again (bool): if True and there are errors, continue trying to check for tasks\n        max_time (int): tasks\n\n    Raises:\n        ValueError: If required inputs are malformed (e.g., `wait_time` must be positive).\n\n    Notes:\n        * To interrupt the waiting, simply use a keyboard escape method.\n        * Use the `try_again` and `max_time` arguments deliberately.\n            * `try_again` can cause the code to continue indefinitely\n            * `max_time` can/will CANCEL tasks in the queue\n\n    Examples:\n        ```python\n        pauseAndWait('task_unique_string')\n        ```\n\n    \"\"\"\n\n    # Raise an error if the wait time is not a positive integer value\n    if wait_time &lt;= 0:\n        raise ValueError('You must specify the wait time as a positive integer (i.e., number of seconds).')\n\n    while True:\n        try:\n            taskList = [str(i) for i in ee.batch.Task.list()]\n            subsetList = [s for s in taskList if unique_id in s]\n            subsubList = [s for s in subsetList if any(xs in s for xs in ['RUNNING', 'READY'])]\n            count = len(subsubList)\n            if count == 0:\n                print('No jobs running!\\n')\n            else:\n                count = 1\n                while count &gt;= 1:\n                    if max_time != None and type(max_time) == int and max_time &gt; 0:\n                        rawTaskList = ee.data.listOperations()\n                        taskList = pd.json_normalize(rawTaskList)\n                        running = taskList.loc[taskList.loc[:,'metadata.state'] == 'RUNNING']\n                        running_copy = running.copy()\n                        running_copy.loc[:,'startSSE'] = running_copy.apply(lambda row: time.mktime(time.strptime(row['metadata.startTime'].replace(\"-\",\"/\"),\"%Y/%m/%dT%H:%M:%S.%fZ\")),axis=1)\n                        running_copy.loc[:,'currentSSE'] = running_copy.apply(lambda row: time.mktime(time.strptime(row['metadata.updateTime'].replace(\"-\",\"/\"),\"%Y/%m/%dT%H:%M:%S.%fZ\")),axis=1)\n                        running_copy.loc[:,'duration'] = running_copy.loc[:,'currentSSE'] - running_copy.loc[:,'startSSE']\n                        opNamesToCancel = running[running_copy.loc[:,'duration'] &gt; max_time]\n                        jobsToCancel = [str(s).split('/')[-1] for s in opNamesToCancel['name']]\n                        for task in rawTaskList:\n                            for job_id in jobsToCancel:\n                                if job_id in task[\"name\"]:\n                                    print(\"Canceling task: \",job_id)\n                                    ee.data.cancelOperation(task[\"name\"])\n                                    print(\"\\n\")\n                    taskList = [str(i) for i in ee.batch.Task.list()]\n                    subsetList = [s for s in taskList if unique_id in s]\n                    subsubList = [s for s in subsetList if any(xs in s for xs in ['RUNNING', 'READY'])]\n                    count = len(subsubList)\n                    print(datetime.datetime.fromtimestamp(time.time()).strftime('%Y-%m-%d %H:%M:%S'), 'Number of queued tasks:', count)\n                    time.sleep(wait_time)\n            print('Moving on...\\n')\n        except (KeyboardInterrupt):\n            sys.exit('Pipeline stopped via keyboard interrupt.')\n        except Exception as error:\n            print(\"Something went wrong when checking the tasks:\")\n            print(error)\n            print(\"\\n\")\n            if try_again == True:\n                print(\"Trying again...\\n\")\n                time.sleep(5)\n                continue\n        break\n</code></pre>"},{"location":"api/#geeode.geeode.check_for_tasks","title":"<code>check_for_tasks(unique_string=str)</code>","text":"<p>A helper function used to check if any tasks within the Earth Engine task queue contains <code>unique_string</code> within their description and are currently in a RUNNING or READY state.</p> <p>Parameters:</p> Name Type Description Default <code>unique_string</code> <code>str</code> <p>will be used to find tasks in your queue that are RUNNING or READY (matched against each tasks <code>description</code>)</p> <code>str</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if at least one matching task is found; otherwise returns <code>False</code></p> <p>Examples:</p> <pre><code>if test_for_tasks('task_unique_string') == True:\n    &lt;do_something_specific_if_tasks_are_running&gt;\n</code></pre> Source code in <code>src/geeode/geeode.py</code> <pre><code>def check_for_tasks(unique_string = str):\n    \"\"\"\n\n    A helper function used to check if any tasks within the Earth Engine task queue\n    contains `unique_string` within their description and are currently in a RUNNING\n    or READY state.\n\n    Args:\n     unique_string (str): will be used to find tasks in your queue that are RUNNING or READY (matched against each tasks `description`)\n\n    Returns:\n        (bool): `True` if at least one matching task is found; otherwise returns `False`\n\n    Examples:\n        ```python\n        if test_for_tasks('task_unique_string') == True:\n            &lt;do_something_specific_if_tasks_are_running&gt;\n        ```\n    \"\"\"\n\n    # Get all task descriptions as strings\n    task_list = [str(t) for t in ee.batch.Task.list()]\n\n    # Keep only those that contain the unique identifier\n    subset_list = [s for s in task_list if unique_string in s]\n\n    # Further filter for tasks that are RUNNING or READY\n    active_tasks = [\n        s for s in subset_list\n        if any(state in s for state in ('RUNNING', 'READY'))\n    ]\n\n    # Return True if there is at least one such task\n    return len(active_tasks) &gt; 0\n</code></pre>"},{"location":"api/#geeode.geeode.check_for_asset_then_run_task","title":"<code>check_for_asset_then_run_task(asset_id_to_test=str, task_to_start=ee.batch.Task, unique_string=str)</code>","text":"<p>A helper function used to check if an asset already exists (or a relevant task is running); if not, then it starts a task of interest</p> <p>Parameters:</p> Name Type Description Default <code>asset_id_to_test</code> <code>str</code> <p>asset id that you will test</p> <code>str</code> <code>task_to_start</code> <code>Task</code> <p>the task you would like to start</p> <code>Task</code> <code>unique_string</code> <code>str</code> <p>a unique string used to test if the task is already running</p> <code>str</code> Notes <ul> <li>It's best to align this function with specific variables used within your   larger workflow; see the example below.</li> <li>Specifically consider using a job <code>description</code> as the <code>unique_string</code></li> </ul> <p>Examples:</p> <pre><code>your_task = ee.batch.Export.&lt;image_or_table&gt;.toAsset(\n                                     ...&lt;other_arguments&gt;...\n                                     assetId = asset_id_to_test,\n                                     description = unique_string,\n)\ntest_for_asset_then_run_task(asset_id_to_test,your_task,unique_string)\n</code></pre> Source code in <code>src/geeode/geeode.py</code> <pre><code>def check_for_asset_then_run_task(asset_id_to_test = str,\n                                 task_to_start = ee.batch.Task,\n                                 unique_string = str):\n    \"\"\"\n    A helper function used to check if an asset already exists (or a relevant task\n    is running); if not, then it starts a task of interest\n\n    Args:\n        asset_id_to_test (str): asset id that you will test\n        task_to_start (ee.batch.Task): the task you would like to start\n        unique_string (str): a unique string used to test if the task is already running\n\n    Notes:\n        * It's best to align this function with specific variables used within your\n          larger workflow; see the example below.\n        * Specifically consider using a job `description` as the `unique_string`\n\n    Examples:\n        ```python\n        your_task = ee.batch.Export.&lt;image_or_table&gt;.toAsset(\n                                             ...&lt;other_arguments&gt;...\n                                             assetId = asset_id_to_test,\n                                             description = unique_string,\n        )\n        test_for_asset_then_run_task(asset_id_to_test,your_task,unique_string)\n\n        ```\n\n    \"\"\"\n    try:\n        # Try to see if the asset exists then except errors or proceed accordingly.\n        ee.data.getAsset(asset_id_to_test)\n        print(f'Asset already exists: {asset_id_to_test}\\n')\n    except ee.EEException:\n        if check_for_tasks(unique_string):\n            print(f'Asset task is already queued: {asset_id_to_test}\\n')\n        else:\n            try:\n                # Try to start the task and return and error if something goes wrong\n                task_to_start.start()\n                print(f'Asset task started: {asset_id_to_test}\\n')\n            except Exception as error:\n                print(f'Something went wrong when starting the task: {asset_id_to_test}\\n')\n    # Return any overarching error if something goes wrong with checking the asset\n    except Exception as error:\n        print(f'Something went wrong when checking for the asset: {asset_id_to_test}')\n        print(error)\n        print('')\n</code></pre>"},{"location":"de_optim_explained/","title":"DE Optimization Explained","text":""},{"location":"de_optim_explained/#conceptual-example","title":"Conceptual Example","text":"<p>The plot shows the true model <code>2\u00b7ln(x+1)+3</code> as a curve together with data points randomly generated (directly from the model).</p> <p>Given the example data, consider the task of optimizing the fit of a logarithmic function:</p> \\[ y = a \\cdot \\ln(x + b) + c \\] <p>For a logarithmic equation in this form, optimize for 3 parameters: </p> \\[ (a,\\;b,\\;c) \\]"},{"location":"de_optim_explained/#1-begin-with-an-initial-population-of-models","title":"1. Begin with an Initial Population of Models","text":"<p>The initial population is a matrix\u2011like list of randomly (or pseudo\u2011randomly) generated vectors:</p> \\[ \\mathbf{P} = \\begin{pmatrix} \\mathit{v_1}\\\\ \\vdots\\\\ \\mathit{v_n} \\end{pmatrix} \\] <p>the element of each vector being parameters from the model being optimized:</p> \\[ \\begin{aligned} \\mathit{v_1} &amp;= (a_1,\\;b_1,\\;c_1)\\\\ &amp; \\ \\ \\ \\ \\ \\ \\ \\ \\ \\vdots \\ \\ \\ \\ \\ \\vdots \\ \\ \\ \\ \\ \\vdots \\ \\ \\ \\ \\ \\\\ \\mathit{v_n} &amp;= (a_n,\\;b_n,\\;c_n) \\end{aligned} \\]"},{"location":"de_optim_explained/#visualize-a-example-population","title":"Visualize a Example Population","text":"<p>Coneptually, the population members can be visualized as multiple curves superimposed on the data.</p> <p></p>"},{"location":"de_optim_explained/#2-define-a-fitness-function","title":"2. Define a Fitness Function","text":"<p>As each member of the population defines a potential model (i.e., curve) to fit over the data, define a fitness function to compare each population member. For example, the root mean square error (RMSE) of each curve can be used:</p> \\[ \\text{RMSE}= \\sqrt{\\frac{\\displaystyle\\sum (y-p)^2}{n}} \\] \\[ \\mathit{Fitness}(\\mathit{v}) = \\text{RMSE}(\\mathit{v}) \\] <p>where</p> <ul> <li>y is the actual value of the data</li> <li>p is the predicted value from a model</li> <li>n is the population size</li> </ul>"},{"location":"de_optim_explained/#3-iterate-the-population","title":"3. Iterate the Population","text":"<p>The population must evolve across discrete steps, called iterations, with each iteration involving 2 procedures: Mutation and Crossover</p>"},{"location":"de_optim_explained/#31-mutation","title":"3.1 Mutation","text":"<p>Mutation involves combining population members to create a new potential mutant population member:</p> \\[ \\mathit{v_m}=F(\\mathit{v_x},\\dots,\\mathit{v_z}) \\] <p>where vm is the mutant vector/model, and v_x through vz are any number of randomly drawn models from the population. Mutation functions are often simple arithmetic combinations of candidate models. For example, the default mutation function in this implementation is: $$ \\mathit{v_m}= \\mathit{v_x}+M\\cdot\\bigl(\\mathit{v_y}-\\mathit{v_z}\\bigr) $$</p> <p>where \\(\\mathit{v_m}\\) is the mutant vector, and \\(\\mathit{v_x}\\) through \\(\\mathit{v_z}\\) are randomly selected models from the population. Additionally, \\(\\mathit{M}\\) is a simple numerical constant set by the user. Constants such as this one are often included in mutation functions as they allow users to influence variation within the mutation process.</p>"},{"location":"de_optim_explained/#32-crossover","title":"3.2 Crossover","text":"<p>Crossover involves selecting or creating a function that determines whether a mutant model replaces any single population member, as this function is applied to every individual population member. A commonly used crossover function is a simple binomial function wherein a randomly determined constant number (between 0 and 1) is compared to a crossover constant:</p> \\[ v_n = v_m\\ if\\ \\mathit{\\mathbf{X}} &gt; C\\ else\\ v_n = v_i \\] <p>where \\(\\mathit{v_n}\\) is the model being recorded during the iteration, \\(\\mathit{v_m}\\) is the potential mutant model, \\(\\mathit{v_i}\\) is the current model being considered, \\(\\mathbfit{X}\\) is a randomly generated constant between 0 and 1, and \\(\\mathit{C}\\) is a simple numerical constant (set by the user) between 0 and 1. In this case, if a user sets a value for \\(\\mathit{C}\\)  that is closer to 0, more mutants substitutions will occur. If the user sets a value closer to 1, fewer substitutions will occur.</p>"},{"location":"de_optim_explained/#4-finalize-via-the-fitness-function","title":"4 Finalize via the Fitness Function","text":"<p>Once the initial population of models has evolved, the final step is to compute the fitness value for each evolved model:</p> \\[ \\mathit{v_final} = \\mathit{Fitness_Best}(\\mathbf{P}) \\] <p>The model with the best fitness value is the optimal solution outputted by the algorithm at that particular iteration. Of note, the algorithm can be iterated any arbitrary number of times. It is best to stop when the algorithm \"converges\" to a model with a fitness function value that does not improve over further iterations.</p>"},{"location":"de_optim_explained/#optimal-solution","title":"Optimal Solution","text":"<p>Shows the underlying model (black), the fittest curve (green), and the original data points.</p>"},{"location":"de_optim_workflows/","title":"Workflow Options","text":""},{"location":"de_optim_workflows/#daisy-chain","title":"\"Daisy-Chain\"","text":"<p>For more in-depth analyses requiring a higher number of iterations on a population, make use of the \"daisy-chain\" functionality. \"Daisy-chaining\" refers to the process of using the outputted population from a previous run.</p> <p>If you follow the quickstart, continue with the following code block:</p> <pre><code>// Call the function a first time and deliver to an export.\nvar firstDeOptimOutput = geeode.de_optim(pop_size,\n                                         iNum,\n                                         funToOpt,\n                                         inputVars,\n                                         inputBounds,\n                                         timeSeries,\n                                         bandName,\n                                         {daisyChain:true});\n\nExport.image.toAsset({\n    image: firstDeOptimOutput,\n    region: aOI,\n    crs: 'EPSG:4326',\n    scale: 10,\n    description: 'daisy_chain_example',\n});\n\n// !! This image asset ID should be updated to your own project space.\nvar daisyChainPopulation = ee.Image('projects/uzheoas/assets/daisy_chain_example');\n\n// Call the function a second time with the daisy-chained population\nvar finalDeOptimOutput = geeode.de_optim(pop_size,\n                                         iNum,\n                                         funToOpt,\n                                         inputVars,\n                                         inputBounds,\n                                         timeSeries,\n                                         bandName,\n                                         {startingPopulationImage:daisyChainPopulation});\nprint('Final DE Optim Output', finalDeOptimOutput);\nMap.addLayer(finalDeOptimOutput, {}, \"DE Optim Output\", false);\n\nvar collWithPredictions = geeode.apply_model(timeSeries, finalDeOptimOutput, funToOpt);\nMap.addLayer(collWithPredictions, {}, 'collWithPredictions', false);\n</code></pre> <p>You can see the example in the GEE Code Playground here.</p> <p>There are 2 specific attributes that an inputted population image must fulfill:</p> <ul> <li>The image must have a property named <code>seed_num</code> with an integer value specified;</li> <li>The dimensions of the embedded array-image must meet dimensionality contraints; in particular:<ul> <li>the number of rows in each pixel-array must equal the specified <code>pop_size</code></li> <li>the number of columns in each pixel-array must equal the number of inputted variables being optimized</li> </ul> </li> </ul>"},{"location":"de_optim_workflows/#custom-population-construction","title":"Custom Population Construction","text":"<p>Due to the design of the algorithm, users can begin their workflow with a  randomly generated set of functions within an initial population and proceed  the evolution process. Or, instead of creating a new population of potential models, users can begin by creating a custom set of population members.</p> <p>These custom populations can be specified in whatever fashion users choose so  long as they match the required format for the function being optimized (i.e.,  their array dimensionality at the pixel level must match the number of  coefficients being optimized and the specified <code>pop_size</code>).</p>"},{"location":"de_optim_workflows/#divide-and-conquer","title":"\"Divide-and-Conquer\"","text":"<p>One approach to custom populations is to begin a workflow by running multiple  sets of randomly generated populations, each being generated with different  random seeds. The results of these populations can then be stacked together  themselves to create a population that can be evolved. Notably, stacks of  coefficient images from any number of <code>de_optim</code> runs can easily be combined  into new populations:</p> <pre><code># Take a collection of combined de_otpim outputs\nchromoColl = ee.ImageCollection([first_deoptim_output_image,second_deoptim_output_image,third_deoptim_output_image])\nchromoBandNames = ee.Image(chrompColl.first()).bandNames();\n\n# This new array-image can now be used as an initial population for a new de_optim run.\nchromoArray = chromColl.select(chromoBandNames.removeAll(['RMSE'])).toArray().set('seed_num',newSeed);\n</code></pre>"},{"location":"de_optim_workflows/#helper-functions","title":"Helper Functions","text":""},{"location":"de_optim_workflows/#pause-and-wait-with-assettask-checks","title":"\"Pause-and-Wait\" with Asset/Task Checks","text":"<p>In order to assist with constructing more in-depth workflows, especially in  situations where daisy-chaining is necessary, <code>geeode</code> offers functions both  to easily check whether a given asset already exists (or is running as an asset) pause the workflow operation until a particular task has completed.</p> <pre><code>result = de_optim(\n    pop_size=10,\n    iNum=25,\n    funToOpt=\"b('time') * a + b\",\n    inputVars=[\"a\", \"b\"],\n    inputBounds=[[0, 1], [0, 10]],\n    timeSeries=time_series,\n    bandName=\"NDVI\",\n)\n\ntask = ee.batch.Export.image.toAsset(\n    image = result,\n    assetId = aID,\n    description = 'Task_Description'\n    ...&lt;other_parameters&gt;\n);\ntask.start()\n\n# Check for the asset then issue the task if it doesn't already exist\ncheck_for_asset_then_run_task(aID,task,'Task_Description')\n\n# Pause the workflow and wait until the task has finished before continuing\npause_and_wait('Task_Description')\n</code></pre> <p>These functions give users the ability to write any number of steps to their  workflows and run them from start to finish without required interactivity.</p>"},{"location":"de_optim_workflows/#adding-time-as-a-band","title":"Adding Time as a Band","text":"<p>If you don't currently have a time variable in your image collection as a band,  consider a function like this one (to add it as a fractional year value at every pixel).</p> <pre><code>// Add Fractional Time to each image pixel\nvar addFractionalTime = function(i) {\n    var yearFraction = ee.Image(i).date().getFraction('year');\n    var yearInteger = ee.Image(i).date().get('year');\n    var fractionalYear = ee.Image.constant(yearInteger.add(yearFraction)).rename('time');\n    return i.addBands(fractionalYear);\n}\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#make-some-example-time-series-data-using-a-specified-model","title":"Make some example time series data using a specified model","text":"<p>First make a series of images with simple numeric values from 1 to 30.</p> <pre><code>// Define an arbitrary area of interest and create the imagery there\nvar aOI = ee.Geometry.Point([8.548333, 47.374722]).buffer(1000).bounds();\nvar projection = ee.Projection(\"EPSG:4326\").atScale(100);\nvar numImColl = ee.ImageCollection(ee.List.sequence(1, 30)\n                .map(function(n) {return ee.Image.constant(n)\n                        .cast({\"constant\": ee.PixelType.int8()}, [\"constant\"])\n                        .set('num', n).rename('num')\n                        .addBands(ee.Image.constant(n).rename('time'))\n                        .clip(aOI).reproject(projection)}))\n                        .cast({'num': 'float','time': 'float'}, ['num', 'time']);\nMap.centerObject(aOI,13);\n</code></pre> <p>Next, use this numeric series of images and choose an arbitrary model \\(a * log(n + b) + c\\) (where \\(a=2\\), \\(b=1\\), and \\(c=3\\)) to prepare an example time series of data (generated from the mathematical model with random error applied).</p> <pre><code>// Describe the model as an expression\nvar expOfChoice = \"2 * log(b('num') + 1) + 3\";\n\n// Apply the algebraic expression to the image collection\nvar expressionApplied = numImColl.map(function(i) {\n    return ee.Image(i.select('num').expression(expOfChoice).rename('num')\n        .copyProperties(i)).addBands(i.select('time'));\n});\n\n// Apply some random error to the series so it's ready to model\n// as an example dataset\nvar maxErrorDecimal = 0.1;\nvar computeError = function(i) {\n    var seed = ee.Number(ee.Image(i).get('num'));\n    var randomField = ee.Image.random(seed, 'normal');\n    var maxError = i.select('num').multiply(ee.Image.constant(maxErrorDecimal));\n    var finalError = maxError.multiply(randomField);\n    var imageToCast = i.select('num').add(finalError).rename('numWithError').addBands(i.select('time'));\n    return ee.Image(imageToCast).float();\n};\n\nvar timeSeries = expressionApplied.map(computeError)\n                                  .map(function(i){return i.set('system:footprint',aOI)});\nMap.addLayer(timeSeries,{},'Example Time Series');\n</code></pre>"},{"location":"quickstart/#input-the-necessary-parameters-to-optimize-the-model-of-interest","title":"Input the necessary parameters to optimize the model of interest","text":"<p>You'll need to ensure that all of your function inputs are properly formatted. You'll find a detailed description of the variable inputs below the demo.</p> <pre><code>// Import geeode\nvar geeode = require('users/uzheoas/geeode:geeode.js');\n\n// Input all necessary parameters\n\n// For a quick demo, use only 10 population members and 10 iterations\nvar pop_size = 10;\nvar iNum = 10;\n\n// Convert the arbitrary model above to expression format\nvar funToOpt = \"b('a') * log(b('time') + b('b')) + b('c')\";\n\n// Input the name of the variables being optimized and the\n// known numeric bounds of the variables\nvar inputVars = ['a','b','c'];\nvar inputBounds = [\n    [0, 10],\n    [0, 10],\n    [0, 10]\n];\n\n// Input the name of the band being modelled (the dependent variable)\nvar bandName = \"numWithError\";\n</code></pre>"},{"location":"quickstart/#call-the-function","title":"Call the function","text":"<p>One you've confirmed all inputs are correctly formatted, call the function.</p> <pre><code>// Call the function\nvar deOptimOutput = geeode.de_optim(pop_size,\n                                    iNum,\n                                    funToOpt,\n                                    inputVars,\n                                    inputBounds,\n                                    timeSeries,\n                                    bandName);\nprint('DE Optim Output', deOptimOutput);\nMap.addLayer(deOptimOutput, {}, \"DE Optim Output\", false);\n</code></pre>"},{"location":"quickstart/#use-the-predicted-parameters-to-visualize-the-model","title":"Use the predicted parameters to visualize the model","text":"<p>Once you have a predicted value from the function you can apply it to the time series using the provided function.</p> <pre><code>var collWithPredictions = geeode.applyModel(timeSeries, deOptimOutput, funToOpt)\nMap.addLayer(collWithPredictions, {}, 'collWithPredictions', false);\n</code></pre>"},{"location":"quickstart/#examine-the-outputs","title":"Examine the outputs","text":"<p>Here's what it looks like when you put it all together. Click around the image to inspect the pixel values of the predicted variables <code>a</code>,<code>b</code>, and <code>c</code> after 10 iterations on 10 population members.</p> <p>The output \"coefficients image\" will contain the same number of bands (with the same names) as the bands/variables you're optimizing within your model. There will also be an <code>RMSE</code> band that contains the root mean square error of the model.</p>"},{"location":"quickstart/#real-world-example","title":"Real World Example","text":"<p>You can find a real world example on an Sentinel-2 NDVI time series here.</p>"},{"location":"subsampling/","title":"Subsampling Explained","text":""},{"location":"subsampling/#collection-size","title":"Collection Size","text":"<p>The <code>de_optim</code> function and algorithm is structured in such a way that larger populations and greater numbers of iterations benefit the optimization process. However, these aspects of the algorithm also face computational limits.</p> <p>Specifically, if you have large image collections (100+) images, it may be efficient (or even necessary) for you to reduce the size of your image collection to overcome computational barriers (e.g., in memory).</p>"},{"location":"subsampling/#temporal-subsampling","title":"Temporal (Sub)Sampling","text":"<p>Image collections in GEE by their design allow for very specific data structures. Consider the following points:</p> <ul> <li>Images in collections do not necessarily overlap.</li> <li>Images in collections do not necessarily share the same pixel mask.</li> <li>Images in collections do not necessarily share the same timestamp.</li> </ul> <p>Due to these attributes, when converting image collections into array-images (e.g., using <code>toArray()</code>) to make a single image wherein each pixel contains a single band that itself is a multi-dimensional array composed of the previous individual images, there will often be many empty values due to missing or masked observations in the original images.</p> <p>Another data-structure implication is that the number of images in the original collection does not necessarily equal the number of actual observations in each pixel cell. If the timestamps for each image are then recorded alongside the observation's value (i.e., as an array image), each pixel grid then has an individual time series recorded at the pixel level (with the added potential for removing missing data values). Pixel grid cells in the array-image (before sampling) will then, often as a result, have varying numbers of observations and the structure could be described as \"jagged\".</p> <p>At this point, it is possible to use the array-image time data as a basis for subsampling from the entire time series stack. Doing so:</p> <ul> <li>reduces the time series size</li> <li>can turn \"jagged\" pixel grid cells into time series of uniform length (without masked observations / NA value \"holes\")</li> </ul>"},{"location":"subsampling/#background","title":"Background","text":"<p>The realities of Earth Observation are that datasets are often \"jagged\" and, moreover, there are often real-world factors that determine the quality of input data.</p> <p>For example, with satellite imagery, clouds frequently contaminate parts of scenes rendering certain pixel locations unusable. As well, clouds themselves often exhibit seasonal patterns (e.g., \"wet\" or \"rainy\" seasons will often have more clouds than \"dry\" seasons). Therefore, datasets not only exhibit hetereogeneity in missing values across a spatial scale but also across a temporal scale.</p> <p></p> <p>The sample time series pictured above illustrates the concepts necessary to understand subsampling. Notice:</p> <ul> <li>The pictured time series has the most points around the center of the time scale.</li> <li>At every point, it's possible to calcuate the number of points neighboring it in time (in other contexts, often called \"kernel density\").</li> <li>When sampling (and therefore reducing the amount of input data) it's optimal first to drop observations with higher temporal density (i.e., denser times) than lower temporal density.</li> </ul>"},{"location":"subsampling/#sampling-methods","title":"Sampling Methods","text":"<p>To understand the sampling methods offered, it's important to understand how simple random sampling works conceptually: given any dataset, it's possible to sample data points by assigning a random numeric value between 0 and 1 (exclusive); one can then order the points by these random numbers, and remove <code>x</code> number of points sequentially from the end of the newly ordered series of datapoints (i.e., the points with the highest or lowest numeric value).</p> <p>This approach to random sampling has the distinct advantage of allowing arithmetic operations on the numeric values used to sort the data. Namely, one can multiply (i.e., scale) each random numeric value assigned to each data point by a weight value. After doing so, data points with higher weight values will have a greater chance of being sorted on one end (the higher end) of the sorted data.</p> <p>For temporal subsampling within GEEODE, the temporal density for each point around a specified time kernel is used as the scaling weight. The higher a point's temporal density is, the greater the chance it will have a higher numeric value when sorting (and thus the greater the likelihood it will be dropped).</p> <p>In each figure, the dots represent the observations ordered by temporal density; the observations with the lowest temporal density are prioritized (i.e, \"on the top\" of each figure). Black dots represent example observations dropped according to the sampling procedure chosen.</p>"},{"location":"subsampling/#simple-weighted-subsampling","title":"Simple Weighted Subsampling","text":"<p>Order the observations by temporal density and remove <code>x</code> numbers of observations starting with the highest and moving towards the lowest such that the desired number of observations is maintained.</p> <p></p>"},{"location":"subsampling/#leapfrog-sampling","title":"\"Leapfrog\" Sampling","text":"<p>Sort the observations by temporal density (descending, such that the observations with the highest temporal density come last). Beginning with the last observation, remove every other observation until <code>n</code> the desired number of observations is achieved.</p> <p></p>"},{"location":"subsampling/#split-shuffle-sampling","title":"\"Split-Shuffle\" Sampling","text":"<p>Sorted by temporal density, assign every observation in order to <code>s</code> number of groups; order the groups individually by temporal density (descending) then order all groups by natural order (group 1, 2, 3, 4). Starting from the end, remove <code>x</code> number of observations until the desired number of observations is maintained.</p> <p>In other words, the original orientation of the weighted observations looks like so:</p> <p></p> <p>After splitting the observations in groups and reordering, the observations would be ordered as such:</p> <p></p>"},{"location":"subsampling/#considerations","title":"Considerations","text":"<p>There are important data-structure implications to this process. Most notably, the structure of the image collection transforms into an image during this process.</p> <p>This image can, of course, be converted back into a formal Image Collection object (e.g., by using the <code>ts_image_to_coll</code> function). However, the individual images in the resulting Image Collection will not maintain any of the original timestamps (and thus must be given a temporal order deliberately). The time data has been shifted from the image-level to the pixel-level.</p> <p>You can then use the time data in/for other pixel level computations, but the missing timestamp data may also affect any future analyses. Consider the implications of changing your data structure when you plan your analytical workflow.</p>"}]}